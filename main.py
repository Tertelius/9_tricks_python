import random as rnd

#  ------ 1. Выбор случайного элемента из последовательности элементов-----
#
#  функция random.choice(seq) позволяет выбрать случайный элемент из индексируемой последовательности. Речь идет о
#  списках, о кортежах и даже о строках.
#


my_list = [1, 2, 5, 8.4, 'go']
print(rnd.choice(my_list))
print(rnd.choice('привет_мир)'))

#  Практический пример:


def book_picker(books):
    book_choice = rnd.choice(books)
    books.remove(book_choice)
    return f"You picked '{book_choice}'"

books = ["Harry potter", "Don Quixote", "Learn Python by Daniel Diaz", "Dracula"]
print(book_picker(books))
print(books)

#  Ограничения и исключения
#  Если попытаться передать функции random.choice(seq) неиндексируемую последовательность, например — словарь,
#  множество или значение числового типа — возникнет ошибка.
#
#  import random as r
#  scores = {"Jhon": 4, "Ben": 3, "Diana": 5}
#
#  print(r.choice(scores)) # Ошибка KeyError
#  Ошибка будет выдана и при попытке передачи этой функции пустой последовательности:
#
#  empty_list = []
#
# print(r.choice(empty_list)) # Ошибка IndexError





#  ----- 2. Распаковка элементов с помощью *
#
# Иногда нужно вывести элементы итерируемого типа, разделив их пробелами. Чаще всего мне доводилось встречать
# такое решение этой задачи:

my_list = [1, 2, 3, 4, 7, 8]

for i in my_list:
    print(i, end=' ')


#  Хотя этот код и решает задачу, он, так сказать, не особенно «питонистический». Гораздо проще будет решение, в
#  котором используется оператор распаковки — *:

print('')
print(*my_list)


#  Обратите внимание на то, что оператор распаковки всегда размещают слева от имени переменной. Этот оператор как бы
#  предлагает Python «разобрать на части» переменную итерируемого типа.
#
#  Итерируемой сущностью считается любая последовательность, которую можно перебрать в цикле for. Если нужно узнать
#  о том, является ли некий тип итерируемым — можно воспользоваться функцией iter().

print(iter("This is a string"))  # Сообщение об объекте str_iterator

print(iter(["this", "is", "a", "list"]))  # Сообщение об объекте list_iterator

#  print(iter(1)) TypeError: 'int' object is not iterable


#  практическое применение:

#  Назначение результатов работы оператора распаковки переменным
#
#  Возможно, после того, как вы узнали о возможностях оператора распаковки, вы захотите пользоваться им для записи
#  данных в переменные. Посмотрим на то, как это сделать:

string = "Let's learn Python"

# Мы собираемся сохранить результат распаковки строки в var1
var1 = [*string]

print(var1)


#  Возможно, вам покажется непонятной конструкция [*iterable]. Поэтому давайте с ней разберёмся.
#
#  Когда мы распаковываем переменную итерируемого типа — Python нуждается в некоей структуре данных, в которую он
#  поместит элементы исходной переменной. Поэтому мы и используем квадратные скобки, представляющие список.
#
#  Вот что можно будет увидеть, если попытаться выяснить тип того, что получилось в результате работы оператора *:


another_str = "The * operator"

# Результаты планируется представить в виде списка
var2 = [*another_str]

print()
print('var2', var2, type(var2))  # list

# Результаты планируется представить в виде кортежа
# При описании кортежа в конце ставится запятая
var3 = (*another_str,)

print()
print('var3', var3, type(var3)) # tuple

#  Конечно, если попытаться распаковать в переменную значение итерируемого типа, не воспользовавшись конструкциями,
#  превращающими результаты распаковки в список или кортеж — будет выдано сообщение о синтаксической ошибке:
#
#  bad_variable = *"Bad String"


